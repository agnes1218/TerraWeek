Terraweek Day 3: Defining and Managing Resources with Terraform

Welcome to Day 3 of Terraweek! Today, we'll dive deeper into the world of Terraform and focus on understanding how to define and manage resources. We'll also explore various resource types and their configurations. Additionally, we'll touch on resource dependencies, *provisioners, and lifecycle management. By the end of this guide, you'll have a solid grasp of these crucial concepts in Terraform. Let's get started!

Defining and Managing Resources with Terraform
Create a Terraform configuration file to define a resource of AWS EC2 instance:

1. Create a Ubuntu Machine on AWS

2. Install Terraform: Download the Terraform binary suitable for your operating system from the official Terraform website. In this demo, I’m setting up Terraform in an AWS EC2 instance(Ubuntu AMI):

 ![image](https://github.com/agnes1218/TerraWeek/assets/46444641/36802a60-7839-4fb9-8e12-41d7be8a454c)

3. Set Up AWS Credentials:

Sign in to the AWS Management Console.
Create an IAM user or use an existing one with appropriate permissions for managing AWS resources. Ensure the user has permissions for EC2, VPC, S3, and other services you plan to work with.

![image](https://github.com/agnes1218/TerraWeek/assets/46444641/61e7fad7-421e-49c7-8c68-784a7b094c8b)


  Generate an access key and secret key for the IAM user. Make a note of these credentials as they will be required for Terraform to interact with AWS.
  Configure the AWS CLI on your EC2 machine by running the following command in your terminal:

  ![image](https://github.com/agnes1218/TerraWeek/assets/46444641/25731b81-4faf-429b-b4ac-f116f04cef15)

4. Create a Terraform configuration file:

Create a new directory for your Terraform configuration files.
Open a terminal and navigate to the new directory.
Create a new Terraform configuration file with a .tf extension (e.g., main. tf). This file will contain your infrastructure code.
In the configuration file, specify the AWS provider and any resources you want to create or manage. For example, you can add the following code to create an AWS EC2 instance:

![image](https://github.com/agnes1218/TerraWeek/assets/46444641/c2ec2ee8-f7c6-4b0f-9075-2adf1adff6b6)

Check State Files and Validate Your .tf File
Check state files before running the plan and apply commands & Use the validate command to validate your .tf file for errors and provide the Output generated by each command.

Initialize the working directory using the init command: 
terraform init

![image](https://github.com/agnes1218/TerraWeek/assets/46444641/c4947067-1a7b-4b32-9f01-cd353aacf734)

Check the existing state files to ensure that Terraform is aware of the current infrastructure:
![image](https://github.com/agnes1218/TerraWeek/assets/46444641/f5321b6b-01ff-40ee-b0c8-c307b986d025)

Run the following command to validate the configuration file for syntax errors and other issues:
terraform validate
![image](https://github.com/agnes1218/TerraWeek/assets/46444641/7e8b4baf-5b28-4d56-b83f-5da015838484)


terraform plan
![image](https://github.com/agnes1218/TerraWeek/assets/46444641/fa92320a-78d3-4c36-88a7-c4e943f395a1)

terraform destroy

terraform destroy command removes all the resources defined in the Terraform configuration, effectively destroying the infrastructure.

![image](https://github.com/agnes1218/TerraWeek/assets/46444641/58167619-64c1-48d9-915f-55c3476f8af5)

![image](https://github.com/agnes1218/TerraWeek/assets/46444641/eb217bbe-d30b-4c53-9868-2eef64ce807b)
![image](https://github.com/agnes1218/TerraWeek/assets/46444641/5d655bf8-2cfc-4e8f-af95-090627519517)


Dependencies 
Terraform, dependencies refer to the relationships between different resources or elements in your Terraform configuration. Understanding dependencies is crucial because Terraform uses this information to determine the order in which resources are created, updated, or destroyed. Terraform uses this information to build a dependency graph, which helps it manage the infrastructure efficiently.

![image](https://github.com/agnes1218/TerraWeek/assets/46444641/1f9cab46-6441-41b9-ba7c-bc81ccc113cd)

In this case, we have two resources: the aws_instance and the aws_db_instance. We want the aws_db_instance to wait until the aws_instance is ready. So we put aws_instance.my-example inside the depends_on attribute of the aws_db_instance.database resource.

When you run Terraform Apply, Terraform will figure out the right order based on these dependencies.

Provisioners: Provisioners are used to execute scripts or commands on resources as part of their lifecycle management. Provisioners allow you to perform tasks such as initializing, configuring, or installing software on resources like virtual machines, containers, or cloud instances. Provisioners are typically used when you need to perform tasks that are not directly supported by the resource's configuration.

![image](https://github.com/agnes1218/TerraWeek/assets/46444641/c1fe0b2d-989e-4aa2-b483-9b0ea7b6d28e)


The AWS EC2 instance (aws_instance resource) is defined with a remote-exec provisioner.
The provisioner uses the inline-block to specify a series of shell commands to be executed on the EC2 instance.
This configuration will create an AWS EC2 instance and execute the specified shell commands on it after it's created.

Task 4:
Add lifecycle management configurations to the configuration file to control the creation, modification, and deletion of the resource and use Terraform commands to apply the changes.

The lifecycle block is used to customize the behavior of specific resource instances throughout their lifecycle. The lifecycle block allows you to control when and how resources are created, replaced, updated, or destroyed. It is particularly useful when you need to fine-tune the behavior of resources in your infrastructure.

![image](https://github.com/agnes1218/TerraWeek/assets/46444641/e7338f81-997c-40d6-ab4a-f5601aef6e80)


Prevent Destroy: This attribute can be used to prevent a specific resource from being destroyed when you run terraform destroy                                                            
Conclusion:
In this blog post, we’ve explored how to manage resources using Terraform,   various resource types, and their configurations, such as AWS EC2 instances. We’ve also discussed resource dependencies, provisioners, and lifecycle management.

Happy Learning!
